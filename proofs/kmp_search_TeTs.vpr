import "IArray.vpr"

// match asserts a MATCH starting at index s in TXT
// M is the length of PAT and N is the length of TXT
define match(pat, m, txt, n, s)
    m > 0 && m <= n && m <= len(pat) && n > 0 && n <= len(txt) && s >= 0 && s < n &&
    forall i: Int :: {slot(pat, i).val, slot(txt, i).val} i >= 0 && i < m ==> slot(pat, i).val == slot(txt, s+i).val

// mismatch asserts a MISMATCH starting at index s in TXT
// M is the length of PAT and N is the length of TXT
define mismatch(pat, m, txt, n, s)
    m > 0 && m <= n && m <= len(pat) && n > 0 && n <= len(txt) && s >= 0 && s < n &&
    exists i: Int :: i >= 0 && i < m ==> slot(pat, i).val != slot(txt, s+i).val

// first_match asserts that a MATCH occurs at index s in TXT,
// and no matches occur before index s
// If no match occurs, s == n
define first_match(pat, m, txt, n, s)
    m > 0 && m <= n && m <= len(pat) && n > 0 && n <= len(txt) && s >= 0 &&
    (s == n ||
    (s < n && match(pat, m, txt, n, s) &&
    forall j: Int :: {slot(pat, j).val, slot(txt, j).val} j >= 0 && j < s ==> mismatch(pat, m, txt, n, j)))

// Main function: verify the kmp search sp method
// M is the length of PAT and N is the length of TXT
// ind is the index of the FIRST MATCH provided by the prover
// If there's no match, then IND == N - M + 1
// b is the supplimentary array generated by the prover, where
//  forall i < ind, b[i] is one index such that txt[i + b[i]] != pat[b[i]]
// output_ind is the output of the program, which differs slightly from ind in case of no match found
method kmp_search_sp(pat: IArray, m: Int, txt: IArray, n: Int, ind: Int, b: IArray) returns (output_ind: Int)
    requires access(pat) && access(txt) && access(b)
    requires m > 0 && m <= n && m <= len(pat) && n > 0 && n <= len(txt) && n <= len(b)
    requires m < maxsize() && n < maxsize()
    ensures access(pat) && access(txt) && access(b)
    ensures output_ind <= n - m || output_ind == n
    ensures first_match(pat, m, txt, n, output_ind)
{
    assume ind >= 0 && ind <= n - m + 1
    var i: Int := 0
    var bi: Int
    // Verify Mismatch
    while (i < maxsize())
        invariant access(b) && access(pat) && access(txt)
        invariant i >= 0
        invariant i - 1 >= 0 && i - 1 < ind ==> 
            exists j: Int :: j >= 0 && j < m ==> slot(pat, j).val != slot(txt, i+j-1).val
    {
        if (i < ind) {
            bi := slot(b, i).val
            assume bi >= 0 && bi < m
            assume slot(pat, bi).val != slot(txt, i+bi).val
        }
        i := i + 1
    }

    i := 0
    // Verify Match
    if (ind != n - m + 1) {
        assert ind < n - m + 1
        while (i < maxsize())
            invariant access(b) && access(pat) && access(txt)
            invariant i >= 0
            invariant i - 1 >= 0 && i - 1 < m ==> slot(pat, i-1).val == slot(txt, ind+i-1).val
        {
            if (i < m) {
                assume slot(pat, i).val == slot(txt, ind+i).val
            }
            i := i + 1
        }
        output_ind := ind
    }
    output_ind := n
}